---
title: 面试常见问题集锦 
tags: 面试,算法,PHP,数据结构,计算机网络,数据库,...
grammar_cjkRuby: true
---

[TOC]

# 排序查找
## 排序
- 快速排序
时间复杂度 O(nlogn)
- 归并排序
时间复杂度 O(nlogn)
- 堆排序
时间复杂度 O(nlogn) 建堆时间复杂度O(n) 
- 冒泡排序
时间复杂度 O(n^2)
- 插入排序
时间复杂度 O(n^2)
- 希尔排序
时间复杂度 O(n^2)
- 选择排序
时间复杂度 O(n^2)


## 查找

- 哈希表查找
时间复杂度O(1)，
- 红黑树查找
时间复杂度O(lgn)

# 数据结构

## 哈希表和红黑树实现的数组（map）有什么区别

> 哈希表实现的map查找速度快，时间复杂度为O(1)，缺点是数据无序  
> 红黑树实现的map查找效率低于哈希表，但可以实现有序存储  


# 数据库

## MyISAM和InnoDB的区别

- MyISAM不支持事务；InnoDB支持事务
- MyISAM不支持外键；InnoDB支持外键
- MyISAM保存表中的具体行数，查询数据总数目的速度快；InnoDB不保存行数，select count(*)会进行全表扫描
- MyISAM支持全文索引，查询效率上MyISAM更高；InnoDB不支持全文索引


## 事务

事务->原子、一致、隔离、持久 （ACID）
事务引发的问题：更新丢失、脏读、不可重复读、幻读

## 查询性能分析

explain分析查询性能

> explain select ......


profile分析语句执行消耗情况

> set profiling=0  
> 执行一些语句  
> show profiles  
> show profile for query 1  
> set profiling=1  

## 数据去重和分组查询

select distinct(num) from test_test; 

select num from test_test group by num;

> group by比distinct快

## 索引

不使用索引进行查询会进行全表扫描，效率低；
使用索引的时候，会减少要查询遍历的结果集数目，加快查询速度；
索引同样会占据空间，在增删改数据的时候，数据库会对索引进行维护，拖慢速度；

常见的索引实现数据结构为B-Tree和HashMap

B-Tree实现的优点：增删查都能在对数时间内完成，数据有序

HashMap可以实现哈希索引，使用哈希索引在寻找指定值的时候效率极高，但无法实现数据比较的操作

## 索引和主键的区别

- 主键是为了标识表中每条数据的唯一性的一个字段，可以理解为一个特殊的唯一索引，但主键的值不能重复不能为空
- 每个数据表只能有一个主键，但是可以有多个索引


## 索引最左匹配原则

> 链家的一面问到这个了......

create  (''|unique|xxx) index index_name on table_name (name,age,xxx)

最左原则通常用于联合索引，

## 数据库查询优化
- 选取正确的字段属性
- 如果可以，尽量把字段设置为not null，这样查询的时候数据库不会去比较null值
- 尽量使用join来代替子查询
- 尽量减少要遍历的结果集
- 合理使用索引，避免索引带来的负面影响，尽量在查询的时候使用索引
- 对用于join、where、判断、order by、外键等字段建立索引，尽量不对大量重复的字段建立索引，比如性别
- 对于查询很少的列尽量不建立索引
- 对大量数据的字段不建立索引

# PHP

## 魔术方法

- call 未定义方法调用的时候
- construct 构造
- destruct 析构
- destory 销毁时执行
- autoload 实例化不存在的类的时候调用
- get&set
- unset 对不存在的变量调用unset时
- clone 对一个对象进行clone操作的时候
- tostring 对象转字符串的时候

## 预定义变量

- $_REQUEST 获取get和post的数据
- $_GET
- $_POST
- $_COOKIE
- $_SESSION
- $_FILE 获取用户提交的文件信息
- $_SERVER 服务器和执行环境的信息

## echo/print/print_r

- echo 是PHP的语法结构 输出多个量 不能输出数组
- print 是PHP的语法结构 输出单个简单变量
- print_r 函数 可以打印复杂变量的结构

## 获取IP

```php
$clientIp=$_SERVER['REMOTE_ADDR'];
$serverIP=$_SERVER['SERVER_ADDR'];
```

## empty()和isset()分析

```php
var_dump(empty(''));            // true
var_dump(empty(""));            // true
var_dump(empty(0));             // true
var_dump(empty('0'));           // true
var_dump(empty("0"));           // true
var_dump(empty(false));         // true
var_dump(empty([]));            // true
var_dump(empty(array()));       // true

var_dump(empty("a"));           // false
var_dump(empty(1));             // false
var_dump(empty('1'));           // false
var_dump(empty("1"));           // false
var_dump(empty(true));          // false
var_dump(empty((new demo())));  // false
```

> 总结：和0相关的单个字符，空字符串，false，空数组，会被认为是empty  
> isset()变量未定义，数组键不存在，对象属性不存在的时候返回false，isset只接受变量名作为参数  

## 字符串函数

### 高效过滤敏感词

> 直接提供一个待过滤词数组，遍历替换

> 正则表达式匹配敏感词进行替换

> 使用字符串函数`strtr()`，传入待过滤的字符串和`关键词/替换词`数组映射，即可完成替换

### 字符串反转

> 直接使用自带的函数`strrev()`

> 使用`str_split()`将字符串按照单个字符分隔成数组，遍历完成倒序拼接

> 或反转数组，使用`implode()`合并

## include/require/include_once/require_once

- include在每次遇到的时候都会进行解释，而require只解释一次
- require的文件被当成当前文件的一个组成部分，如果require的文件本身有错误或文件不存在，脚本将会停止执行；include只会抛出警告而不会中断
- require_once每次包含的时候都会判断是否已经包含过，所以效率低于require

# 计算机网络

## TCP和UDP的区别

TCP面向连接；UDP无连接
TCP可以进行数据的可靠传输；UDP不能保证可靠性
TCP传递的是字节流；UDP传送数据报文段
TCP速度慢，占用资源高；UDP速度快，占用资源低

> 应用场景：TCP用于邮件、文件发送等必须进行可靠传输的方面；UDP适合在线直播等对数据传输可靠性要求低，对数据传输速度要求高的方面

## 三次握手

Client发送SYN-一次握手
Server收到SYN，回复ACK，同时发送SYN-二次握手
Client收到SYN，回复ACK-第三次握手

> 三次握手的目的是：Client确认自己的发送和接收正常，Server的发送接收正常；Server确认自己的发送接收正常，Client的发送接收正常

## 四次挥手

Client发送FIN-一次挥手
Server收到FIN，回复ACK-二次挥手
Server发送FIN-三次挥手
Client收到FIN，回复ACK-四次挥手

> 四次挥手的作用是分别对两端的连接进行关闭，并且双方对关闭进行确认

# HTTP

## 报文

Http报文即浏览器和服务器通信的一个数据包，包含header和body两部分

header包含url、Content-Type等头部信息；body包含http的主体信息（真正要发送的数据）

## 缓存机制

可以理解为客户端有一个缓存数据库，可以存放需要缓存的内容

根据是否向服务器发送请求，主要分为两种类型：

- 强制缓存

第一次访问服务器获得数据之后，根据返回的Http头的缓存规则信息，对数据进行缓存，下次访问不会连接服务器，而是直接返回缓存的数据

- 对比缓存

第一次访问的时候，缓存起来，下次访问，会带上缓存的内容向服务器发送请求，服务器进行判断，如果缓存未失效直接返回状态304，不需要重新返回内容，减少了http报文长度和请求时间

## Cookie

- name cookie的key
- value cookie的值
- expires 过期时间
- domain 可以访问此Cookie的域名
- httponly 是否只能通过http操作Cookie（是否允许js操作cookie）
- secure 是否只能在https中传输

## Cookie跨域问题

一般情况下Cookie不能跨域。

如果需要Cookie跨域访问，可以使用Nginx反向代理，对浏览器进行欺骗，让浏览器认为是同源调用，同时欺骗真实的目标服务器，让服务器以为该请求来自用户的浏览器

## Cookie和Session的区别

- Cookie存放在客户端；Session存放在服务端，读取session会消耗服务器资源
- Cookie在每次Http请求的时候会被携带在Http的header中发送到服务器端；Session只保存在服务器端，只能被服务端读取
- 第一次创建Session的时候，需要在客户端设置一个SESSIONID，使客户端和服务端的Session产生关联，也就是Session基于Cookie
- cookie的大小有限制（3k）；session大小无限制
- session是公有的，存储在服务器端，更安全

> 如果客户端禁用Cookie，可以使用URL重写技术实现session跟踪，类似GET方式传递参数，在URL中包含SESSIONID信息

## 状态码

- 200：从客户端发送到服务器的请求被正确处理 
- 301资源永久移动
- 302临时移动
- 304未修改
- 400请求的报文存在语法错误
- 401未授权（UnAuthorized）
- 403访问被拒绝（Forbidden）
- 404在服务器上没有找到资源（Not Found）
- 405请求的方法不允许（Method Not Allow）
- 500服务器内部错误
- 502错误网关

# 业务问题

## 单点登录

实现原理：使用统一的授权中心进行道路状态的管理和令牌的发放

- 进入系统1
- 发现未登录
- 跳转到授权中心进行登录
- 登陆完成返回Token
- 系统1登录完成
- 进入系统2
- 发现未登录
- 转到授权中心
- 授权中心已登录
- 发放Token
- 系统2完成登录


# 安全问题

## PHP基本配置

- 线上环境关闭PHP错误提示
- 严格配置项目文件权限

## 表单安全设计

- 前端页面验证数据类型（不安全，但是可以提高用户体验）
- 后台验证用户输入（重要）
- 不信任用户的输入，防止xss，防止sql注入
- 防止用户上传非法的文件，进行文件类型的验证，或进行文件上传的隔离（例如使用OSS）

## 用户输入数据安全性

- 判断用户操作的数据是否存在
- 用户操作的数据是否有权限
- 数据类型是否正确
- 数据长度验证
- 是否包含危险字符



## XSS

- 对用户输入的关键字符进行过滤
- 对关键字符转义
- 过滤输入的html标签

## XSRF（CSRF）

- 尽量使用POST提交数据
- 加验证码
- 加CSRF Token



## WebShell

- 关键在于防止非法上传的webshell执行
- 对用户上传文件进行类型验证
- 隔离文件，单独设置域名进行访问，不给予执行权限
- 使用OSS，托管文件到第三方，本服务器只存储文件地址


## SQL注入

- 对危险字符进行过滤
- 不直接使用用户输入拼接SQL
- 使用MySQLi或者PDO的SQL预编译功能






# Redis

默认端口：6379

